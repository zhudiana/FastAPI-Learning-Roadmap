## Generate JWT Access Tokens

Previously, our login endpoint only returned `"Successful authentication"` or `Failed authentication`. Now we will upgrade it to return a **JWT (JSON Web Token)** that clients can use to authenticate themselves in future requests.

### Step 1: Install Required Packages

Install `python-jose` with cryptography support (for JWTs):

```bash
pip install "python-jose[cryptography]"
```

Generate a secret key for signing tokens:

```bash
python -c "import secrets; print(secrets.token_hex(32))"
```

### Step 2: Imports and Config

In `auth.py`, add:

```python
from jose import jwt
from datetime import datetime, timedelta, timezone
```

Define constants:

```python
SECRET_KEY = 'your generated secret'
ALGORITHM = 'HS256'
```

### Step 3: Token Model

```python
class Token(BaseModel):
    access_token: str
    token_type: str
```

This Pydantic model defines the structure of the JWT response.

### Step 4: Update `authenticate_user`

Instead of returning just `True`, we now return the actual user object so that we can include user details (like `username` and `id`) inside the JWT.

```python
def authenticate_user(username: str, password: str, db):
    user = db.query(Users).filter(Users.username == username).first()
    if not user:
        return False
    if not bcrypt_context.verify(password, user.hashed_password):
        return False
    return user
```

### Step 5: Create Access Token Function

```python
def create_access_token(username: str, user_id: int, expires_delta: timedelta):
    encode = {"sub": username, "id": user_id}
    expires = datetime.now(timezone.utc) + expires_delta
    encode.update({"exp": expires})
    return jwt.encode(encode, SECRET_KEY, algorithm=ALGORITHM)
```

- `sub`: standard JWT claim (subject → here we store username).
- `id`: user’s unique ID.
- `exp`: expiration time → ensures token will become invalid after the set duration.
- `jwt.encode(...)`: creates the signed JWT string.

### Step 6: Update the Login Endpoint

```python
@router.post("/token", response_model=Token)
def login_for_access_token(form_data: Annotated[OAuth2PasswordRequestForm, Depends()], db: db_dependency):
    user = authenticate_user(form_data.username, form_data.password, db)
    if not user:
        return "Failed Authentication"
    token = create_access_token(user.username, user.id, timedelta(minutes=20))
    return {"access_token": token, "token_type": "Bearer"}
```

- If authentication fails → return `"Failed Authentication"`.
- If authentication succeeds → generate a JWT with `username` and `user_id`.
- Return the JWT as `access_token` with `token_type` `"Bearer"`.

---

### Testing in Swagger UI

1. Go to `/docs`.
2. Use the `/token` endpoint.
3. Enter your **username** and **password**.
4. If valid, the response will look like this:

```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR...",
  "token_type": "Bearer"
}
```
