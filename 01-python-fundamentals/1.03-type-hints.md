## Type Hints

- Type hints are an important feature in Python.

- They let us specify the expected **type** of a variable, function parameter, or return value.

- This helps us with _readability_ and provides an opportunity to _catch errors_ **before runtime** using type checkers like mypy.

  - In plain python, type hints are only hints. they don't enforce anything at run time. We will see what we mean with an example.

#### 1. Variable Type Hints

```python
name: str = "Judy"
age: int = 25
```

> - _name_ is a string.
> - _age_ is an integer.

#### 2. Function Type Hints

> `say_hi()` function expects a string and returns a string (`->str`)

```python
def say_hi(name: str) -> str:
    return f"Hi {name}"

print(say_hi("Alex"))  # Hi Alex
print(say_hi(45))      # Hi 45

```

> In the above example, you'd run the code and no error would appear. You might say "we are expecting a string return but passing an integer didn't raise any error". It is because, as we said, _*in plain python, type hints are only hints*_. Unless you install type checker and run it to complain before running, the code will run perfectly. **(In FastAPI, it doesn't just read your type hints, it _enforces_ them automatically at runtime)**

- You can declare all the standard python types (str, int, float, bool, bytes).

### Generic types with type parameters

There are some data structures that can contain other values, like `dict`, `list`, `set` and `tuple`. And the internal values can have their own type too.

#### List

```python
def process_items(items: list[str]):
  for item in items:
    print(item)
```

> Those internal types in the square brackets are called _type parameters_. In this case, `str` is the type parameter passed to `list`

#### Tuple and Set

You would do the same to declare `tuple`s and `set`s:

```python
def process_items(items_t: tuple[int, int, str], items_s: set[bytes]):
  return items_t, items_s
```

#### Dict

To define a `dict`, you pass 2 type parameters, separated by commas.

- The first type parameter is for the **keys** of the `dict`.

- The second type parameter is for the **values** of the `dict`.

```python
def process_items(prices: dict[str, float]):
  for item_name, item_price in prices.items():
    print(item_name)
    print(item_price)
```

#### Union

You can declare that a variable can be any of **several types**, for example, an `int` or a `str`.

```python
def process_item(item: str | int):
  print(item)
```

> This means that _item_ could be an `int` or a `str`.

#### Possibly `None`

You can declare that a value could have a type like `str`, but that it could also be `None`.

```python
def say_hi(name: str | None = None):
  if name is not None:
    print(f"Hey {name}!")
  else:
     print("Hello World")
```
